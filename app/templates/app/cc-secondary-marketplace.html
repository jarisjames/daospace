{% load static %}
{% load humanize %}
<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="{% static 'Images/Logos/DaospaceLogo.svg' %}" type="image/svg+xml">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contributor Cards - Secondary Market</title>
    <link rel="stylesheet" href="{% static 'css/home.css' %}">

    <style>
      /* =======================
         Overlay & Zoom Styles
         ======================= */
      .model-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 9998;
      }
      .model-overlay.active {
        display: flex;
      }
      .model-overlay-content {
        position: relative;
        max-width: 90vw;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        overflow: visible;
      }
      #bigModelViewer {
        width: 80vw;
        height: 80vh;
        background: transparent;
        disable-zoom: true;
        field-of-view: 50deg;
        --poster-color: transparent;
      }
      .model-overlay-close {
        font-size: 24px;
        margin-bottom: 5px;
        margin-right: 5px;
        background: transparent;
        color: #fff;
        border: none;
        cursor: pointer;
        z-index: 10000;
      }
      .zoom-slider-container {
        position: absolute;
        top: 50%;
        left: 10px;
        transform: translateY(-50%);
        z-index: 10001;
      }
      #zoomSlider {
        writing-mode: bt-lr;
        -webkit-appearance: slider-vertical;
        width: 8px;
        height: 200px;
        background: #444;
        border-radius: 5px;
        cursor: pointer;
      }
      #zoomSlider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        background: #fff;
        border-radius: 50%;
        cursor: pointer;
      }
      #zoomSlider::-moz-range-thumb,
      #zoomSlider::-ms-thumb {
        width: 20px;
        height: 20px;
        background: #fff;
        border-radius: 50%;
        cursor: pointer;
      }

      /* Leverage .dao-list / .dao-item / .dao-header from home.css */

      /* For partial-buy input alignment */
      .buy-quantity-input {
        width: 50px;
        margin-right: 5px;
      }

      /* =======================
         GLB Selection Styles
         ======================= */
      .glb-selection {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
      }
      .glb-item {
        position: relative;
        width: 150px;
        height: 150px;
        border: 2px solid transparent;
        border-radius: 10px;
        overflow: hidden;
        cursor: pointer;
        transition: border 0.3s;
      }
      .glb-item.selected {
        border: 2px solid #00f;
      }
      .glb-item model-viewer {
        width: 100%;
        height: 100%;
      }
      .glb-item .token-id {
        position: absolute;
        bottom: 5px;
        left: 5px;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        padding: 2px 5px;
        border-radius: 3px;
        font-size: 12px;
      }
      .glb-selection-title {
        width: 100%;
        margin-bottom: 10px;
        font-weight: bold;
      }

      /* Additional Styles for Enhanced UI */
      .dao-list {
        list-style: none;
        padding: 0;
      }
      .dao-item {
        display: flex;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #ccc;
      }
      .dao-number {
        width: 30px;
        text-align: center;
        font-weight: bold;
      }
      .dao-header {
        display: flex;
        align-items: center;
        flex-grow: 1;
        position: relative;
      }
      .dao-metrics {
        margin-left: 15px;
      }
      .buy-button {
        padding: 5px 10px;
        margin-left: 5px;
        cursor: pointer;
        background-color: #28a745;
        color: #fff;
        border: none;
        border-radius: 3px;
        transition: background-color 0.3s;
      }
      .buy-button:hover {
        background-color: #218838;
      }
      .buy-button.cancel {
        background-color: #c82333;
      }
      .buy-button.cancel:hover {
        background-color: #bd2130;
      }
      .enlarge-hint {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        text-align: center;
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        font-size: 10px;
        padding: 2px 0;
      }

      /* Loading Spinner */
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #09f;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      /* Responsive Adjustments */
      @media (max-width: 768px) {
        .glb-item {
          width: 100px;
          height: 100px;
        }
        #bigModelViewer {
          width: 90vw;
          height: 60vh;
        }
      }
    </style>
</head>
<body>
    <!-- Logo Container -->
    <div class="logo-container">
        <a href="{% url 'home' %}">
            <img src="{% static 'Images/Logos/DaospaceLogo.svg' %}" alt="Daospace Logo">
        </a>
    </div>

    <!-- Server-Side Animation URL Mapping -->
    <script>
      window.serverSideAnimationUrls = JSON.parse('{{ cards_dict_json|escapejs }}');
    </script>

    <div class="content-wrapper">
      <div class="centered-box">
        <h2>Contributor Cards - Secondary Market</h2>

        <div class="button-container">
          <a href="{% url 'contributor_cards_marketplace' %}" class="btn-link">Primary Marketplace</a>
          <a href="{% url 'claim_contributor_card' %}" class="btn-link">Claim Your Contributor Card (RARI Foundation Only)</a>
      </div>
      
      <style>
          .button-container {
              display: flex;
              justify-content: center;
              align-items: center;
              margin-top: 40px; /* Adjusted margin for spacing */
              gap: 15px;
          }
      
          .btn-link {
              display: inline-block;
              padding: 8px 16px;
              font-size: 12.5px;
              font-weight: bold;
              text-transform: uppercase;
              letter-spacing: 1px;
              color: #ff6600; /* Warm gradient-inspired color */
              text-decoration: none;
              border: 2px solid #ff6600;
              border-radius: 6px;
              background: rgba(0, 0, 0, 0.8);
              transition: all 0.3s ease-in-out;
              box-shadow: 0 0 6px rgba(255, 102, 0, 0.6), 0 0 12px rgba(255, 102, 0, 0.3);
          }
      
          .btn-link:hover {
              background: linear-gradient(45deg, #ff6600, #ffcc00); /* Gradient inspired by logo */
              color: #000;
              box-shadow: 0 0 12px rgba(255, 102, 0, 0.9), 0 0 24px rgba(255, 204, 0, 0.6);
          }
      </style>
<br>           

        <!-- Listing Form -->
        <div style="margin-bottom: 20px;">
          <h3>Create Listing</h3>

          <!-- GLB Selection -->
          <div class="glb-selection">
            <div class="glb-selection-title">Select Your Token:</div>
            <!-- Dynamically populated by JS -->
          </div>

          <!-- Hidden Input to Store Selected Token ID -->
          <input type="hidden" id="selectedTokenId" value="">

          <!-- Quantity Input -->
          <div style="margin-bottom: 10px;">
            <label for="quantityInput">Quantity:</label>
            <input type="number" id="quantityInput" placeholder="1" min="1" style="margin-left: 10px;">
          </div>
          <!-- Price Input -->
          <div style="margin-bottom: 10px;">
            <label for="priceInput">Price (ETH):</label>
            <input type="text" id="priceInput" placeholder="e.g., 0.05" style="margin-left: 10px;">
          </div>
          <!-- List Button -->
          <button id="listNftButton">List NFT</button>
          <!-- Status Message -->
          <div id="statusMessage" style="margin-top: 10px; color: green; font-weight: bold;"></div>
        </div>

        <!-- Active Listings -->
        <h3>Active Listings</h3>
        <div id="listingsLoading" class="spinner" style="display: none;"></div>
        <ul class="dao-list" id="listingsUL">
          <!-- Dynamically populated by JS -->
        </ul>
      </div>
    </div>

    <!-- Bottom Nav -->
    <nav class="bottom-nav">
        <div class="nav-row">
            <a href="#" class="nav-item nav-trending">Trending</a>
            <a href="{% url 'daos' %}" class="nav-item nav-daos">DAOs</a>
        </div>
        <div class="nav-row">
            <a href="#" class="nav-item nav-events">Events</a>
            <a href="{% url 'contributor_cards_marketplace' %}" class="nav-item nav-marketplace">Marketplace</a>
        </div>
    </nav>

    <!-- Fullscreen Overlay for big model -->
    <div id="modelOverlay" class="model-overlay">
      <div class="model-overlay-content">
        <!-- Vertical slider for zoom -->
        <div class="zoom-slider-container">
          <input
            type="range"
            id="zoomSlider"
            min="10"
            max="50"
            step="1"
            value="50"
            orient="vertical"
          >
        </div>
        <!-- Close button -->
        <button class="model-overlay-close" id="modelOverlayClose">&times;</button>
        <!-- Big model-viewer -->
        <model-viewer
          id="bigModelViewer"
          camera-controls
          auto-rotate
          enable-pan
          disable-zoom
          alt="Full-screen Model Viewer"
        >
        </model-viewer>
      </div>
    </div>

    <!-- Model Viewer Script -->
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>

    <!-- web3.js -->
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.7.5/dist/web3.min.js"></script>

    <!-- Full ABI (Secondary Marketplace Contract), NOT truncated -->
    <script>
    const contributorCardsAbi = [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        }
      ],
      "name": "cancelListing",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "quantity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pricePerToken",
          "type": "uint256"
        }
      ],
      "name": "createListing",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "quantities",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "pricePerTokens",
          "type": "uint256[]"
        }
      ],
      "name": "createListingsBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "quantity",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "ipfsMetadataUri",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "contributor",
          "type": "address"
        }
      ],
      "name": "lazyMint",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        }
      ],
      "name": "ListingCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "originalQuantity",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "pricePerToken",
          "type": "uint256"
        }
      ],
      "name": "ListingCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newPrice",
          "type": "uint256"
        }
      ],
      "name": "ListingPriceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "quantity",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalPrice",
          "type": "uint256"
        }
      ],
      "name": "ListingPurchased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newQuantity",
          "type": "uint256"
        }
      ],
      "name": "ListingQuantityUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "newIpfsUri",
          "type": "string"
        }
      ],
      "name": "MetadataUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "quantity",
          "type": "uint256"
        }
      ],
      "name": "purchaseFromListing",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "quantity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expectedTotalPrice",
          "type": "uint256"
        }
      ],
      "name": "purchaseFromSeller",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "listingIds",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "quantities",
          "type": "uint256[]"
        }
      ],
      "name": "purchaseListingsBatch",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeBatchTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        }
      ],
      "name": "TransferBatch",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TransferSingle",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "newPricePerToken",
          "type": "uint256"
        }
      ],
      "name": "updateListingPrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "listingId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "newQuantity",
          "type": "uint256"
        }
      ],
      "name": "updateListingQuantity",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "newIpfsUri",
          "type": "string"
        }
      ],
      "name": "updateMetadata",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "value",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "URI",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "accounts",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        }
      ],
      "name": "balanceOfBatch",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getMintedCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LAZY_MINT_PRICE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_SUPPLY_PER_TOKEN",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_salePrice",
          "type": "uint256"
        }
      ],
      "name": "royaltyInfo",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "uri",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
    ];
    </script>

<!-- Simplified JavaScript for Enlarge Functionality and Listings Management -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    console.log("Secondary Market with GLB Selection and Active Listings loaded.");

    // =========================
    // 1. Web3 Setup
    // =========================

    // 1A. A dedicated read-only Web3 to RARI Chain (always used for reading data):
    const rariRpcUrl = "https://mainnet.rpc.rarichain.org/http";
    const readWeb3 = new Web3(new Web3.providers.HttpProvider(rariRpcUrl));
    // The same contract address, but connected to readWeb3
    const contractAddress = "0xe06f3fe83e1579f6db6f75d865b3a19f545e2277";
    const readContract = new readWeb3.eth.Contract(contributorCardsAbi, contractAddress);

    // 1B. A wallet-based web3 (optional, only used for writing if user has a wallet)
    let web3 = null;
    let contract = null;
    let userAddress = null;
    let isWalletConnected = false;

    if (typeof window.ethereum !== 'undefined') {
      web3 = new Web3(window.ethereum);
      contract = new web3.eth.Contract(contributorCardsAbi, contractAddress);

      try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        if (accounts.length > 0) {
          userAddress = accounts[0];
          isWalletConnected = true;
          console.log("Wallet connected:", userAddress);
        }
      } catch (err) {
        console.error("User denied account access:", err);
        // We'll stay read-only for queries
      }
    }

    // If user has no wallet, or user denied, we do NOT overwrite readWeb3 / readContract.
    // We'll still show listings from readContract.

    // =========================
    // 2. Helper Functions
    // =========================

    const statusEl = document.getElementById("statusMessage");
    const listingsLoading = document.getElementById("listingsLoading");
    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? "red" : "green";
      console.log(msg);
    }

    // RARI Chain parameters for "wallet_switchEthereumChain" or "wallet_addEthereumChain"
    const desiredChainIdDecimal = 1380012617; // decimal
    const desiredChainIdHex = "0x52415249";   // hex

    // Force user to RARI Chain for any transaction
    async function ensureOnRariChain() {
      if (!web3 || !window.ethereum) {
        throw new Error("No wallet connected. Please install MetaMask or another web3 wallet.");
      }
      try {
        const currentChainId = await web3.eth.getChainId();
        if (currentChainId !== desiredChainIdDecimal) {
          // Try switching
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: desiredChainIdHex }]
          });
        }
      } catch (switchError) {
        // If chain is not added, add it
        if (switchError.code === 4902) {
          try {
            await window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: [{
                chainId: desiredChainIdHex,
                chainName: "RARI Chain Mainnet",
                nativeCurrency: {
                  name: "Ethereum",
                  symbol: "ETH",
                  decimals: 18
                },
                rpcUrls: [rariRpcUrl],
                blockExplorerUrls: ["https://mainnet.explorer.rarichain.org"]
              }]
            });
            // Then switch
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: desiredChainIdHex }]
            });
          } catch (addError) {
            console.error("Failed to add RARI chain:", addError);
            throw new Error("Failed to add RARI Chain to your wallet.");
          }
        } else {
          console.error("Failed to switch chain:", switchError);
          throw new Error("Failed to switch to RARI Chain. Please try manually in MetaMask.");
        }
      }
    }

    // For address display
    function truncateAddress(address) {
      if (!address) return "";
      return address.slice(0, 6) + "..." + address.slice(-4);
    }

    // Convert server-side tokenId -> animation_url
    const serverAnimationMap = window.serverSideAnimationUrls || {};

    // =========================
    // 3. Build Listings from Events (READ-ONLY)
    // =========================

    // We'll store listings in a local object
    const listingsData = {};

    async function buildListingsFromEvents() {
      const fromBlock = 0; // or your deployment block
      const toBlock = "latest";

      try {
        // Always read from readContract, so it doesn't matter if user is on the wrong chain
        const createdEvents = await readContract.getPastEvents("ListingCreated", { fromBlock, toBlock });
        const cancelledEvents = await readContract.getPastEvents("ListingCancelled", { fromBlock, toBlock });
        const priceUpdatedEvents = await readContract.getPastEvents("ListingPriceUpdated", { fromBlock, toBlock });
        const purchasedEvents = await readContract.getPastEvents("ListingPurchased", { fromBlock, toBlock });

        // Reset local state
        for (const k in listingsData) {
          delete listingsData[k];
        }

        // Created
        createdEvents.forEach(ev => {
          const rv = ev.returnValues;
          listingsData[rv.listingId] = {
            listingId: rv.listingId,
            seller: rv.seller,
            tokenId: parseInt(rv.tokenId, 10),
            remainingQuantity: parseInt(rv.originalQuantity, 10),
            priceWei: rv.pricePerToken,
            active: true
          };
        });

        // Cancelled => active=false
        cancelledEvents.forEach(ev => {
          const listingId = ev.returnValues.listingId;
          if (listingsData[listingId]) {
            listingsData[listingId].active = false;
          }
        });

        // Price updated
        priceUpdatedEvents.forEach(ev => {
          const rv = ev.returnValues;
          if (listingsData[rv.listingId] && listingsData[rv.listingId].active) {
            listingsData[rv.listingId].priceWei = rv.newPrice;
          }
        });

        // Purchased => reduce quantity
        purchasedEvents.forEach(ev => {
          const rv = ev.returnValues;
          const listingId = rv.listingId;
          if (!listingsData[listingId] || !listingsData[listingId].active) return;

          const qty = parseInt(rv.quantity, 10);
          listingsData[listingId].remainingQuantity -= qty;
          if (listingsData[listingId].remainingQuantity <= 0) {
            listingsData[listingId].active = false;
          }
        });
      } catch (err) {
        console.error("Error fetching listing events:", err);
        setStatus("Error fetching listings from RARI Chain.", true);
      }
    }

    // =========================
    // 4. Render Listings
    // =========================

    async function loadAllListings() {
      listingsLoading.style.display = "block";
      setStatus("Loading listings from RARI Chain...");

      await buildListingsFromEvents();

      const listingsUL = document.getElementById("listingsUL");
      listingsUL.innerHTML = "";

      const allIds = Object.keys(listingsData).sort((a, b) => parseInt(a) - parseInt(b));
      let listingCounter = 0;

      for (const id of allIds) {
        const data = listingsData[id];
        if (!data.active) continue;
        if (data.remainingQuantity <= 0) continue;

        listingCounter++;

        // Build <li>
        const li = document.createElement("li");
        li.className = "dao-item";

        // Left number
        const daoNumberDiv = document.createElement("div");
        daoNumberDiv.className = "dao-number";
        daoNumberDiv.innerHTML = `<span>${listingCounter}.</span>`;

        // dao-header
        const daoHeaderDiv = document.createElement("div");
        daoHeaderDiv.className = "dao-header";

        // Model viewer
        const tokenIdStr = String(data.tokenId);
        const animationUrl = serverAnimationMap[tokenIdStr] || "";

        const modelViewer = document.createElement("model-viewer");
        modelViewer.className = "mini-model";
        modelViewer.setAttribute("camera-controls", "");
        modelViewer.setAttribute("auto-rotate", "");
        modelViewer.style.width = "100px";
        modelViewer.style.height = "100px";
        modelViewer.style.cursor = "pointer";
        modelViewer.alt = "Contributor Card Preview";

        if (animationUrl) {
          modelViewer.src = animationUrl;
        }

        // "Click to Enlarge" hint (optional text)
        const enlargeHint = document.createElement("div");
        enlargeHint.className = "enlarge-hint";
        enlargeHint.textContent = "";

        // dao-metrics
        const daoMetricsDiv = document.createElement("div");
        daoMetricsDiv.className = "dao-metrics";
        const contributorNamesMap = JSON.parse('{{ contributor_names_dict_json|escapejs }}');

        const contributorName = contributorNamesMap[data.tokenId] || "Unknown";
        const priceEth = readWeb3.utils.fromWei(String(data.priceWei), "ether");

        daoMetricsDiv.innerHTML = `
          <div>Contributor: ${contributorName}</div>
          <div>Seller: ${truncateAddress(data.seller)}</div>
          <div>Token ID: ${data.tokenId}</div>
          <div>Remaining: ${data.remainingQuantity}</div>
          <div>Price: ${priceEth} ETH</div>
        `;

        daoHeaderDiv.appendChild(modelViewer);
        daoHeaderDiv.appendChild(enlargeHint);
        daoHeaderDiv.appendChild(daoMetricsDiv);

        // Buy/cancel area
        const actionDiv = document.createElement("div");

        // partial-buy input
        const buyQtyInput = document.createElement("input");
        buyQtyInput.type = "number";
        buyQtyInput.className = "buy-quantity-input";
        buyQtyInput.min = "1";
        buyQtyInput.max = data.remainingQuantity;
        buyQtyInput.value = "1";
        actionDiv.appendChild(buyQtyInput);

        // buy button
        const buyBtn = document.createElement("button");
        buyBtn.className = "buy-button";
        buyBtn.textContent = "Buy";
        actionDiv.appendChild(buyBtn);

        // Cancel button if user is seller
        let cancelBtn = null;
        if (
          isWalletConnected &&
          data.seller.toLowerCase() === (userAddress || "").toLowerCase()
        ) {
          cancelBtn = document.createElement("button");
          cancelBtn.className = "buy-button cancel";
          cancelBtn.textContent = "Cancel";
          actionDiv.appendChild(cancelBtn);
        }

        // Build final structure
        li.appendChild(daoNumberDiv);
        li.appendChild(daoHeaderDiv);
        li.appendChild(actionDiv);
        listingsUL.appendChild(li);

        // ==================
        //  Buy Button Logic
        // ==================
        buyBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          const qty = parseInt(buyQtyInput.value, 10);
          if (!qty || qty < 1) {
            setStatus("Invalid quantity.", true);
            return;
          }
          if (qty > data.remainingQuantity) {
            setStatus("Not enough quantity.", true);
            return;
          }
          if (!isWalletConnected) {
            setStatus("Please connect your wallet to buy.", true);
            return;
          }
          // 1) Ensure on RARI
          try {
            await ensureOnRariChain();
          } catch (chainErr) {
            setStatus(chainErr.message, true);
            return;
          }

          // 2) Send TX
          try {
            setStatus(`Buying ${qty} from listing #${id}...`);
            const totalCost = (BigInt(data.priceWei) * BigInt(qty)).toString();
            // must use the wallet-based contract
            const txObj = contract.methods.purchaseFromListing(id, qty);

            const gasEstimate = await txObj.estimateGas({
              from: userAddress,
              value: totalCost
            });
            const gasPrice = await web3.eth.getGasPrice();

            const receipt = await txObj.send({
              from: userAddress,
              value: totalCost,
              gas: gasEstimate,
              gasPrice
            });
            setStatus(`Purchase success! Tx: ${receipt.transactionHash}`);

            // Reload listings
            await loadAllListings();
          } catch (err) {
            console.error("Purchase failed:", err);
            setStatus("Purchase failed: " + err.message, true);
          }
        });

        // =====================
        // Cancel Button Logic
        // =====================
        if (cancelBtn) {
          cancelBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            if (!isWalletConnected) {
              setStatus("Please connect your wallet to cancel.", true);
              return;
            }
            // 1) Ensure on RARI
            try {
              await ensureOnRariChain();
            } catch (chainErr) {
              setStatus(chainErr.message, true);
              return;
            }

            // 2) Send TX
            try {
              setStatus(`Canceling listing #${id}...`);
              const txObj = contract.methods.cancelListing(id);

              const gasEstimate = await txObj.estimateGas({ from: userAddress });
              const gasPrice = await web3.eth.getGasPrice();

              const receipt = await txObj.send({
                from: userAddress,
                gas: gasEstimate,
                gasPrice
              });
              setStatus(`Listing #${id} canceled! Tx: ${receipt.transactionHash}`);

              // Reload listings
              await loadAllListings();
            } catch (err) {
              console.error("Cancel failed:", err);
              setStatus("Cancel failed: " + err.message, true);
            }
          });
        }
      }

      if (listingCounter === 0) {
        const emptyLi = document.createElement("li");
        emptyLi.className = "dao-item";
        emptyLi.textContent = "No active listings at the moment.";
        listingsUL.appendChild(emptyLi);
      }

      setStatus("Listings loaded!");
      listingsLoading.style.display = "none";
    }

    // =========================
    // 5. Overlay Logic (Enlarge Model)
    // =========================

    const overlay = document.getElementById("modelOverlay");
    const overlayClose = document.getElementById("modelOverlayClose");
    const bigModelViewer = document.getElementById("bigModelViewer");
    const zoomSlider = document.getElementById("zoomSlider");
    let currentFov = 50;

    // Enlarge a listing model
    const listingsUL = document.getElementById("listingsUL");
    listingsUL.addEventListener("click", (event) => {
      const miniModel = event.target.closest('.mini-model');
      if (miniModel && miniModel.src) {
        bigModelViewer.setAttribute('src', miniModel.src);
        overlay.classList.add('active');
      }
    });
    // Prevent click collisions
    listingsUL.addEventListener("click", (event) => {
      if (event.target.closest('.buy-button') || event.target.closest('.buy-quantity-input')) {
        event.stopPropagation();
      }
    });

    overlayClose.addEventListener("click", () => {
      overlay.classList.remove('active');
      bigModelViewer.removeAttribute('src');
    });
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.classList.remove('active');
        bigModelViewer.removeAttribute('src');
      }
    });
    zoomSlider.addEventListener("input", (evt) => {
      currentFov = parseInt(evt.target.value, 10);
      bigModelViewer.setAttribute("field-of-view", `${currentFov}deg`);
    });

    // =========================
    // 6. Create New Listing
    // =========================

    const listBtn = document.getElementById("listNftButton");
    listBtn.addEventListener("click", async () => {
      setStatus("Preparing listing...");
      if (!isWalletConnected) {
        setStatus("Please connect your wallet to list NFT.", true);
        return;
      }

      // 1) ensure on RARI
      try {
        await ensureOnRariChain();
      } catch (chainErr) {
        setStatus(chainErr.message, true);
        return;
      }

      // 2) read form data
      const selectedTokenId = document.getElementById("selectedTokenId").value;
      const qtyStr = (document.getElementById("quantityInput").value || "").trim();
      const priceEthStr = (document.getElementById("priceInput").value || "").trim();

      if (!selectedTokenId || !qtyStr || !priceEthStr) {
        setStatus("Please select a token, quantity, and price.", true);
        return;
      }
      const tokenId = parseInt(selectedTokenId, 10);
      const quantity = parseInt(qtyStr, 10);
      if (isNaN(tokenId) || isNaN(quantity) || quantity < 1) {
        setStatus("Invalid token ID or quantity.", true);
        return;
      }
      let priceWei;
      try {
        priceWei = web3.utils.toWei(priceEthStr, "ether");
      } catch (err) {
        setStatus("Invalid price: " + err.message, true);
        return;
      }

      // 3) check user’s balance (read from readContract)
      setStatus("Checking your token balance on RARI...");
      try {
        const bal = await readContract.methods.balanceOf(userAddress, tokenId).call();
        if (parseInt(bal, 10) < quantity) {
          setStatus("You do not have enough tokens to list.", true);
          return;
        }
      } catch (err) {
        setStatus("Failed to check balance: " + err.message, true);
        return;
      }

      // 4) check existing listings
      await buildListingsFromEvents();
      let sumActive = 0;
      for (const lId in listingsData) {
        const listing = listingsData[lId];
        if (
          listing.active &&
          listing.seller.toLowerCase() === userAddress.toLowerCase() &&
          listing.tokenId === tokenId
        ) {
          sumActive += listing.remainingQuantity;
        }
      }
      // If user already listed all, or if they'd exceed their balance
      // you can do an additional check here if needed

      // 5) check approval
      setStatus("Checking approval...");
      try {
        const isApproved = await readContract.methods.isApprovedForAll(userAddress, contractAddress).call();
        if (!isApproved) {
          setStatus("Requesting approval in MetaMask...");
          const txObj = contract.methods.setApprovalForAll(contractAddress, true);
          const gas = await txObj.estimateGas({ from: userAddress });
          const gasPrice = await web3.eth.getGasPrice();
          await txObj.send({ from: userAddress, gas, gasPrice });
          setStatus("Approved! Creating listing...");
        } else {
          setStatus("Already approved. Creating listing...");
        }
      } catch (err) {
        setStatus("Error requesting approval: " + err.message, true);
        return;
      }

      // 6) create the listing
      try {
        const txObj = contract.methods.createListing(tokenId, quantity, priceWei);
        const gas = await txObj.estimateGas({ from: userAddress });
        const gasPrice = await web3.eth.getGasPrice();
        const receipt = await txObj.send({
          from: userAddress,
          gas,
          gasPrice
        });
        setStatus(`Listing created! Tx: ${receipt.transactionHash}`);

        // reload listings
        await loadAllListings();

        // reset selection
        resetGlbSelection();
      } catch (err) {
        console.error("createListing failed:", err);
        setStatus("createListing failed: " + err.message, true);
      }
    });

    // =========================
    // 7. GLB Selection
    // =========================

    const glbSelectionDiv = document.querySelector(".glb-selection");
    function resetGlbSelection() {
      const glbItems = document.querySelectorAll(".glb-item");
      glbItems.forEach(item => item.classList.remove("selected"));
      document.getElementById("selectedTokenId").value = "";
    }

    async function loadOwnedTokens() {
      // If the user has no wallet, or is not connected, we just skip
      if (!isWalletConnected) {
        glbSelectionDiv.innerHTML += "<div>Please connect your wallet to list your tokens.</div>";
        return;
      }
      setStatus("Loading your tokens from RARI...");

      const contributorNamesMap = JSON.parse('{{ contributor_names_dict_json|escapejs }}');
      const ownedTokens = [];

      // Check which tokenIds the user owns
      const allTokenIds = Object.keys(serverAnimationMap).map(k => parseInt(k, 10));

      try {
        // We can read from readContract as well
        const balancePromises = allTokenIds.map(tokenId =>
          readContract.methods.balanceOf(userAddress, tokenId).call()
        );
        const balances = await Promise.all(balancePromises);
        balances.forEach((bal, idx) => {
          if (parseInt(bal, 10) > 0) {
            ownedTokens.push(allTokenIds[idx]);
          }
        });
      } catch (err) {
        console.error("Error fetching balances:", err);
        setStatus("Error fetching your balances from RARI.", true);
        return;
      }

      if (ownedTokens.length === 0) {
        glbSelectionDiv.innerHTML += "<div>You do not own any tokens to list.</div>";
        setStatus("No tokens found in your wallet (on RARI).");
        return;
      }

      // Build the GLB items
      ownedTokens.forEach(tokenId => {
        const glbItem = document.createElement("div");
        glbItem.className = "glb-item";
        glbItem.dataset.tokenId = tokenId;

        const modelViewer = document.createElement("model-viewer");
        modelViewer.setAttribute("src", serverAnimationMap[String(tokenId)]);
        modelViewer.setAttribute("camera-controls", "");
        modelViewer.setAttribute("auto-rotate", "");
        modelViewer.setAttribute("shadow-intensity", "1");
        modelViewer.setAttribute("alt", "TokenID " + tokenId);
        modelViewer.style.width = "100%";
        modelViewer.style.height = "100%";

        const contributorName = contributorNamesMap[tokenId] || "Unknown";
        const tokenIdLabel = document.createElement("div");
        tokenIdLabel.className = "token-id";
        tokenIdLabel.textContent = `ID: ${tokenId} - ${contributorName}`;

        glbItem.appendChild(modelViewer);
        glbItem.appendChild(tokenIdLabel);

        glbItem.addEventListener("click", () => {
          // Deselect others
          document.querySelectorAll(".glb-item").forEach(item => item.classList.remove("selected"));
          glbItem.classList.add("selected");
          document.getElementById("selectedTokenId").value = tokenId;
          setStatus(`Selected Token ID: ${tokenId}`);

          // Optionally enlarge
          if (modelViewer.src) {
            bigModelViewer.setAttribute('src', modelViewer.src);
            overlay.classList.add('active');
          }
        });

        glbSelectionDiv.appendChild(glbItem);
      });

      setStatus("Tokens loaded. Please select one to list.");
    }

    // =========================
    // 8. Initialize
    // =========================

    async function initialize() {
      // Always load listings from readContract
      await loadAllListings();

      // Only load tokens if user is connected
      await loadOwnedTokens();
    }

    initialize();
  });
</script>



</body>
</html>
